/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag centroid decomposition, dp
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
const int mod = 1e9 + 7;
const int inf = 1.2e9;
const int maxn = 1e5 + 10;

int add(int a, int b) {
  return (a + b)%mod;
}

int mul(ll a, ll b) {
  return a * b%mod;
}

int k;
int res[maxn];
struct CentroidDecomposition {
	vector<vector<int>> T;
	vector<int> sz, P;
	vector<bool> block;
	CentroidDecomposition(int n):
		T(n), sz(n), P(n, -1), block(n) {}
	void add_edge(int a, int b) {
		T[a].emplace_back(b);
		T[b].emplace_back(a);
	}
	bool valid(int x, int p) {
		return x != p && !block[x];
	}
	//calculate sizes
	int dfs(int x, int p=-1) {
		sz[x] = 1;
		for (int v : T[x]) if (valid(v, p))
			sz[x] += dfs(v, x);
		return sz[x];
	}
	//gradient descendt algorithm
	int get_centroid(int x, int p, int n) {
		for (int v : T[x]) 
		    if (valid(v, p) && 2 * sz[v] > n)
				return get_centroid(v, x, n);
		return x;
	}
	void dfs_add(int x, int p, int d, int h) {
	    res[h] += d;    
	    for (auto v : T[x]) {
	        if (!valid(v, p)) continue;
	        dfs_add(v, x, d, h+1);
	    }
	}
	int dfs_cnt(int x, int p, int h) {
	    int ans = 0;
	    if (k - h >= 0) ans = res[k-h];
	    for (auto v : T[x]) {
	        if (!valid(v, p)) continue;
	        ans = add(ans, dfs_cnt(v, x, h+1));
	    }
	    return ans;
	}
	int decompose(int x=0, int p=-1) {
		int n = dfs(x);
		int cen = get_centroid(x, -1, n);
		res[0] = 1;
		int ans = 0;
		for (int v : T[cen]) {
		    if (block[v]) continue;
		    ans = add(ans, dfs_cnt(v, cen, 1));
		    dfs_add(v, cen, 1, 1);
		}
		dfs_add(cen, -1, -1, 0);
		P[cen] = p; //centroid parent 
		block[cen] = 1; //block node
		for (auto v : T[cen]) {
			if (block[v]) continue;
			ans = add(ans, decompose(v, cen));
		}
		return ans;
	}
};

class A {
public:
    void solveOne(istream& in, ostream& out) {
      int n;
      in >> n >> k;
      CentroidDecomposition tree(n);
      re(i, 0, n-1) {
        int a, b;
        in >> a >> b;
        tree.add_edge(a-1, b-1);
      }
      out << mul(k *1ll*(k+1) / 2 % mod, tree.decompose()) << endl;
    }

    void solve(istream& in, ostream& out) {
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};
 
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	A solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
